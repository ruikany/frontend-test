<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Realtime STT Client</title>
    <style>
      body {
        background-color: #1a1a1a;
        color: #e0e0e0;
        font-family: "Courier New", Courier, monospace;
        padding: 20px;
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      #controls {
        margin-bottom: 20px;
        padding: 20px;
        background: #2d2d2d;
        border-radius: 12px;
        text-align: center;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
      }
      input {
        padding: 10px;
        background: #333;
        border: 1px solid #555;
        color: white;
        width: 300px;
        border-radius: 4px;
        margin-bottom: 10px;
      }
      button {
        padding: 12px 24px;
        cursor: pointer;
        background-color: #007bff;
        color: white;
        border: none;
        border-radius: 6px;
        font-weight: bold;
        font-size: 16px;
        transition: background-color 0.2s;
        min-width: 150px;
      }
      button:hover {
        background-color: #0056b3;
      }
      button:disabled {
        background-color: #555;
        cursor: not-allowed;
      }
      button.recording {
        background-color: #dc3545; /* Red for stop */
        animation: pulse 2s infinite;
      }
      button.recording:hover {
        background-color: #c82333;
      }
      @keyframes pulse {
        0% {
          box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.7);
        }
        70% {
          box-shadow: 0 0 0 10px rgba(220, 53, 69, 0);
        }
        100% {
          box-shadow: 0 0 0 0 rgba(220, 53, 69, 0);
        }
      }
      #status {
        margin-top: 15px;
        font-size: 0.9em;
        color: #888;
        min-height: 1.2em;
      }
      #textDisplay {
        width: 90%;
        max-width: 800px;
        min-height: 400px;
        border: 1px solid #444;
        padding: 20px;
        border-radius: 8px;
        background-color: #000;
        line-height: 1.6;
        white-space: pre-wrap;
        overflow-y: auto;
        max-height: 70vh;
      }
      .yellow {
        color: #f1c40f;
      }
      .cyan {
        color: #00e5ff;
      }
      .realtime {
        color: #888;
        font-style: italic;
      }
    </style>
  </head>
  <body>
    <div id="controls">
      <h3 style="margin-top: 0">STT Interface</h3>
      <input
        type="text"
        id="wsUrl"
        value="ws://localhost:8000/ws/transcribe"
        placeholder="WebSocket URL"
      />
      <br />
      <button id="recordBtn" onclick="toggleRecording()">
        Start Recording
      </button>
      <div id="status">Ready</div>
    </div>

    <div id="textDisplay"></div>

    <script>
      let socket;
      let audioContext;
      let processor;
      let inputSource;
      let isConnected = false;
      let fullSentences = [];
      let stream; // Keep reference to close stream later

      const statusDiv = document.getElementById("status");
      const displayDiv = document.getElementById("textDisplay");
      const recordBtn = document.getElementById("recordBtn");
      const wsUrlInput = document.getElementById("wsUrl");

      function toggleRecording() {
        if (isConnected) {
          stopApp();
        } else {
          startApp();
        }
      }

      function updateDisplay(realtimeText) {
        let html = fullSentences
          .map(
            (s, i) =>
              `<span class="${i % 2 === 0 ? "yellow" : "cyan"}">${s}</span> `,
          )
          .join("");

        if (realtimeText) {
          html += `<span class="realtime">${realtimeText}</span>`;
        }
        displayDiv.innerHTML = html;
        displayDiv.scrollTop = displayDiv.scrollHeight;
      }

      async function startApp() {
        const wsUrl = wsUrlInput.value;
        recordBtn.disabled = true;
        wsUrlInput.disabled = true;
        statusDiv.textContent = "Connecting...";

        try {
          // 1. Get Microphone Access
          stream = await navigator.mediaDevices.getUserMedia({
            audio: {
              echoCancellation: true,
              noiseSuppression: true,
              autoGainControl: true,
            },
          });

          // 2. Connect WebSocket
          socket = new WebSocket(wsUrl);

          socket.onopen = () => {
            statusDiv.textContent = "Connected. Initializing...";
          };

          socket.onmessage = (event) => {
            const data = JSON.parse(event.data);

            if (data.type === "status" && data.text === "ready") {
              // Server is ready, start sending audio
              startAudioProcessing(stream);
              setUIState(true);
              statusDiv.textContent = "ðŸ”´ Recording...";
            } else if (data.type === "realtime") {
              updateDisplay(data.text);
            } else if (data.type === "fullSentence") {
              fullSentences.push(data.text);
              updateDisplay("");
            }
          };

          socket.onclose = () => {
            // Triggers when server closes connection or we manually close
            stopApp();
          };

          socket.onerror = (err) => {
            console.error("Socket Error:", err);
            statusDiv.textContent = "Connection Error.";
            stopApp();
          };
        } catch (err) {
          console.error("Mic Error:", err);
          statusDiv.textContent = "Microphone Error: " + err.message;
          setUIState(false);
        }
      }

      function stopApp() {
        // Clean up Audio
        stopAudioProcessing();

        // Clean up Socket
        if (socket) {
          // Remove listener to prevent recursion if we are calling stopApp from onclose
          socket.onclose = null;
          socket.close();
          socket = null;
        }

        // Close Mic Stream (turns off browser recording dot)
        if (stream) {
          stream.getTracks().forEach((track) => track.stop());
          stream = null;
        }

        setUIState(false);
        statusDiv.textContent = "Stopped.";
      }

      function setUIState(recording) {
        isConnected = recording;
        recordBtn.disabled = false;
        wsUrlInput.disabled = recording; // Lock URL while recording

        if (recording) {
          recordBtn.textContent = "Stop Recording";
          recordBtn.classList.add("recording");
        } else {
          recordBtn.textContent = "Start Recording";
          recordBtn.classList.remove("recording");
        }
      }

      function startAudioProcessing(currentStream) {
        audioContext = new AudioContext();
        inputSource = audioContext.createMediaStreamSource(currentStream);

        // 4096 buffer size = ~85ms latency @ 48kHz, efficient for network
        processor = audioContext.createScriptProcessor(4096, 1, 1);

        inputSource.connect(processor);
        processor.connect(audioContext.destination);

        processor.onaudioprocess = (e) => {
          if (!isConnected || !socket || socket.readyState !== WebSocket.OPEN)
            return;

          const inputData = e.inputBuffer.getChannelData(0);
          const outputData = new Int16Array(inputData.length);

          // Convert to 16-bit PCM
          for (let i = 0; i < inputData.length; i++) {
            outputData[i] = Math.max(
              -32768,
              Math.min(32767, inputData[i] * 32768),
            );
          }

          // Send Blob
          const metadata = JSON.stringify({
            sampleRate: audioContext.sampleRate,
          });
          const metadataBytes = new TextEncoder().encode(metadata);
          const lenBuffer = new ArrayBuffer(4);
          new DataView(lenBuffer).setInt32(0, metadataBytes.byteLength, true);

          const blob = new Blob([lenBuffer, metadataBytes, outputData.buffer]);
          socket.send(blob);
        };
      }

      function stopAudioProcessing() {
        if (processor) {
          processor.disconnect();
          processor = null;
        }
        if (inputSource) {
          inputSource.disconnect();
          inputSource = null;
        }
        if (audioContext) {
          audioContext.close();
          audioContext = null;
        }
      }
    </script>
  </body>
</html>
